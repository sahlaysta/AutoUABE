#pragma once
#include "api.h"
#include "MainWindow2.h"
#include "FileDialog.h"
#include "../libStringConverter/convert.h"
#include "../UABE_Generic/AssetPluginUtil.h"
#include <unordered_map>
#include <unordered_set>
#include <tuple>
#include <array>
#include <vector>
#include <list>
#include <memory>
#include <concepts>
#include <stdint.h>
#include <regex>

class AssetModifyDialog
{
private:
	std::list<std::shared_ptr<AssetModifyDialog>>::iterator selfHandle; //Set and used internally by AssetListDialog.
public:
	UABE_Win32_API AssetModifyDialog();
	UABE_Win32_API virtual ~AssetModifyDialog();
	//Called when the user requests to close the tab.
	//Returns true if there are unsaved changes, false otherwise.
	//If the function will return true and applyable is not null,
	// *applyable will be set to true iff applyNow() is assumed to succeed without further interaction
	// (e.g. all fields in the dialog have a valid value, ...).
	//The caller uses this info to decide whether and how it should display a confirmation dialog before proceeding.
	virtual bool hasUnappliedChanges(bool* applyable = nullptr) = 0;
	//Called when the user requests to apply the changes (e.g. selecting Apply, Save or Save All in the menu).
	//Returns whether the changes have been applied;
	// if true, the caller may continue closing the AssetModifyDialog.
	// if false, the caller shall stop closing the AssetModifyDialog.
	//Note: applyChanges() is expected to notify the user about errors (e.g. via MessageBox).
	virtual bool applyChanges() = 0;
	virtual std::string getTabName() = 0;
	virtual HWND getWindowHandle() = 0;
	//Called for unhandled WM_COMMAND messages. Returns true if this dialog has handled the request, false otherwise.
	virtual bool onCommand(WPARAM wParam, LPARAM lParam) = 0;
	virtual void onHotkey(ULONG message, DWORD keyCode) = 0; //message : currently only WM_KEYDOWN; keyCode : VK_F3 for instance
	//Called when the dialog is to be shown. The parent window will not change before the next onHide call.
	virtual void onShow(HWND hParentWnd) = 0;
	//Called when the dialog is to be hidden, either because of a tab switch or while closing the tab.
	virtual void onHide() = 0;
	//Called when the tab is about to be destroyed.
	//Once this function is called, AssetListDialog::removeModifyDialog must not be used for this dialog.
	virtual void onDestroy() = 0;

	friend class AssetListDialog;
};

struct NameTypeCacheKey
{
	unsigned int fileID;
	int32_t classID;
	uint16_t monoTypeID;
	inline NameTypeCacheKey()
		: fileID(0), classID(0), monoTypeID(0xFFFF)
	{}
	inline NameTypeCacheKey(unsigned int fileID, int32_t classID, uint16_t monoTypeID)
		: fileID(fileID), classID(classID), monoTypeID(monoTypeID)
	{}
	inline bool operator==(const NameTypeCacheKey& other) const
	{
		return fileID == other.fileID &&
			classID == other.classID &&
			monoTypeID == other.monoTypeID;
	}
};

namespace std
{
	template<>
	struct hash<NameTypeCacheKey>
	{
		inline std::size_t operator()(NameTypeCacheKey const& key) const
		{
			static std::hash<decltype(key.fileID)> fidHasher;
			static std::hash<decltype(key.classID)> cidHasher;
			static std::hash<decltype(key.monoTypeID)> mtidHasher;
			size_t fidHash = fidHasher(key.fileID);
			size_t cidHash = cidHasher(key.classID);
			size_t mtidHash = mtidHasher(key.monoTypeID);
			size_t seed = 0;
			//Seed calculation stolen from boost (hash_combine) : 
			/*
			Boost Software License - Version 1.0 - August 17th, 2003

			Permission is hereby granted, free of charge, to any person or organization
			obtaining a copy of the software and accompanying documentation covered by
			this license (the "Software") to use, reproduce, display, distribute,
			execute, and transmit the Software, and to prepare derivative works of the
			Software, and to permit third-parties to whom the Software is furnished to
			do so, all subject to the following:

			The copyright notices in the Software and this entire statement, including
			the above license grant, this restriction and the following disclaimer,
			must be included in all copies of the Software, in whole or in part, and
			all derivative works of the Software, unless such copies or derivative
			works are solely in the form of machine-executable object code generated by
			a source language processor.

			THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
			IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
			FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
			SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
			FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
			ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
			DEALINGS IN THE SOFTWARE.
			*/
			seed ^= fidHash + 0x9e3779b9 + (seed << 6) + (seed >> 2);
			seed ^= cidHash + 0x9e3779b9 + (seed << 6) + (seed >> 2);
			seed ^= mtidHash + 0x9e3779b9 + (seed << 6) + (seed >> 2);
			return seed;
		}
	};
}

class AssetListDialog : public IFileManipulateDialog, public MainWindowEventHandler
{
	struct AssetInfo
	{
		std::string name; //(from the m_Name field)
		std::string containerName;
		std::string typeName;
		uint64_t size;
		uint32_t typeID;
		uint16_t monoScriptID;
		bool isModified; //Has a replacer.
		inline size_t getSize()
		{
			//Rough approximation (overcounts or undercounts the std::string memory size).
			return name.size() + containerName.size() + typeName.size() + sizeof(AssetInfo);
		}
	};
	//Caches AssetInfo elements for assets of a file. Registers itself on the FileEntryUIInfo pointer.
	struct FileEntryCache : public MainWindowEventHandler, public UIDisposableCache
	{
		class Win32AppContext* pContext;
		MainWindowEventHandlerHandle eventHandlerHandle;
		size_t nUsers;
		time_t lastUseTime;


		FileEntryCache(FileEntryUIInfo* pUIInfo, Win32AppContext* pContext);
		~FileEntryCache();
		size_t approxMemory();
		time_t getLastUseTime();
		bool isInUse();

		void onUpdateContainers(AssetsFileContextInfo* pFile);
		void onChangeAsset(AssetsFileContextInfo* pFile, pathid_t pathID, bool wasRemoved);

		FileEntryUIInfo* pUIInfo;
		std::unordered_map<pathid_t, AssetInfo> assetCache;
	};
	typedef UIDisposableCacheRef<FileEntryCache> FileEntryCacheRef;
	inline AssetInfo* tryGetCacheEntry(unsigned int fileID, pathid_t pathID)
	{
		auto fileIt = fileEntries.find(fileID);
		if (fileIt != fileEntries.end())
		{
			FileEntryCache& cache = *fileIt->second.get();
			auto entryIt = cache.assetCache.find(pathID);
			if (entryIt != cache.assetCache.end())
			{
				return &entryIt->second;
			}
		}
		return nullptr;
	}
	//Last determined number of selections; May not be precise at some points.
	size_t lastNumSelections;

	UABE_Win32_API AssetUtilDesc makeExportDescForSelection(size_t selection);
	//Simple iterator over the selected listEntry elements in an AssetListDialog.
	//Iterating over all selected elements has linear time complexity in listEntry.size().
	//Note: Should not be used across window event handler calls, since the listEntries vector could change in between.
	// Opening a new message handler (e.g. MessageBox, DialogBox) on the thread is not recommended for the same reason,
	//  unless the iterator object will no longer be queried or incremented.
	class ListEntrySelectionIterator
	{
		AssetListDialog& dialog;
		size_t selection;
		size_t nextSelection;
	public:
		UABE_Win32_API ListEntrySelectionIterator(AssetListDialog& dialog);
		inline bool hasNext()
		{
			return nextSelection != SIZE_MAX;
		}
		inline bool isEnd()
		{
			return selection == SIZE_MAX;
		}
		inline size_t operator*()
		{
			return selection;
		}
		UABE_Win32_API ListEntrySelectionIterator& operator++();
		inline ListEntrySelectionIterator operator++(int)
		{
			ListEntrySelectionIterator ret = *this;
			++ret;
			return ret;
		}
	};

public:
	struct ListEntry
	{
		unsigned int fileID;
		pathid_t pathID;
		bool isSelected;
		ListEntry(unsigned int fileID, pathid_t pathID, bool isSelected = false)
			: fileID(fileID), pathID(pathID), isSelected(isSelected)
		{}
	};
	inline std::string* getName(unsigned int fileID, pathid_t pathID)
	{
		if (AssetInfo* pInfo = tryGetCacheEntry(fileID, pathID)) return &pInfo->name;
		return nullptr;
	}
	inline std::string* getContainerName(unsigned int fileID, pathid_t pathID)
	{
		if (AssetInfo* pInfo = tryGetCacheEntry(fileID, pathID)) return &pInfo->containerName;
		return nullptr;
	}
	inline std::string* getTypeName(unsigned int fileID, pathid_t pathID)
	{
		if (AssetInfo* pInfo = tryGetCacheEntry(fileID, pathID)) return &pInfo->typeName;
		return nullptr;
	}
	inline uint64_t getSize(unsigned int fileID, pathid_t pathID)
	{
		if (AssetInfo* pInfo = tryGetCacheEntry(fileID, pathID)) return pInfo->size;
		return 0;
	}
	inline uint32_t getTypeID(unsigned int fileID, pathid_t pathID)
	{
		if (AssetInfo* pInfo = tryGetCacheEntry(fileID, pathID)) return pInfo->typeID;
		return (uint32_t)INT32_MIN;
	}
	inline uint16_t getMonoScriptID(unsigned int fileID, pathid_t pathID)
	{
		if (AssetInfo* pInfo = tryGetCacheEntry(fileID, pathID)) return pInfo->monoScriptID;
		return 0xFFFF;
	}
	inline bool getIsModified(unsigned int fileID, pathid_t pathID)
	{
		if (AssetInfo* pInfo = tryGetCacheEntry(fileID, pathID)) return pInfo->isModified;
		return false;
	}

	UABE_Win32_API void addModifyDialog(std::shared_ptr<AssetModifyDialog> dialog);
	UABE_Win32_API void removeModifyDialog(AssetModifyDialog* pDialog);
	UABE_Win32_API std::shared_ptr<AssetModifyDialog> getModifyDialogRef(AssetModifyDialog* pDialog);
private:
	MainWindowEventHandlerHandle eventHandlerHandle;
	class Win32AppContext* pContext;
	HWND hDialog; bool windowUpdateScheduled; bool selectionUpdateScheduled;
	HWND hParentWnd;
	HMENU hCurPopupMenu = NULL;
	std::unordered_map<unsigned int, FileEntryCacheRef> fileEntries;
	std::vector<ListEntry> listEntries; //The assets in the list control order. pFile, pathID

	std::list<std::shared_ptr<AssetModifyDialog>> modifyDialogs;
	std::shared_ptr<AssetModifyDialog> pActiveModifyDialog;

	size_t cachedListEntryStartIdx;
	size_t cachedListEntryCount;
	bool entryCachingScheduled;
	LARGE_INTEGER qpfrequency; //QueryPerformanceFrequency
	size_t maxEntriesPerTick, ticksUntilCacheFreqUpdate;
	void onCacheUpdateTick();

	std::vector<unsigned int> gotoDlg_uiToFileIDMapping;

	std::string searchQuery;
	bool searchDirectionUp = false;
	bool searchCaseSensitive = false;
	std::regex searchRegex;
	void searchNext();

	struct DeferredChangeDesc
	{
		pathid_t pathID;
		bool wasRemoved;
	};
	std::map<unsigned int, std::vector<DeferredChangeDesc>> deferredChangesByFileID;
	void applyDeferredChanges();

	bool sorted;
	bool sortOrderAscending;
	int iSortColumn;
	int iFocusedItem;
	int iLastTopItem;
	//Returns false if the user cancelled caching.
	bool cacheAllAndShowProgress(bool allowCancel);
	void listEntryInsertSorted(ListEntry newEntry, size_t targetIdx = (size_t)-1);
	void resort();

	void getContainerInfo(AssetsFileContextInfo* pContextInfo, pathid_t pathID, OUT std::string& baseName, OUT std::string& containerListName);
	//Assumes that iItem has been bounds checked already (i.e. 0 <= iItem < listEntries.size()).
	//newTextBuf will be created with new TCHAR[].
	void getEntryText(int iItem, int iSubItem, AssetInfo& entry, OUT std::unique_ptr<TCHAR[]>& newTextBuf);

	//Updates the right half description depending on selection.
	void updateSelectionDesc();

	void requestRemoveSelectedAssets();

	bool preDeleteTab(MC_NMMTCLOSEITEM* pNotification);
	void onDeleteTab(MC_NMMTDELETEITEM* pNotification);
	void onSwitchTabs(MC_NMMTSELCHANGE* pNotification);

	void openViewDataTab(size_t selection = SIZE_MAX);
	void onExportDumpButton();
	void onPluginButton();

	struct NameTypeCacheValue
	{
		DWORD nameChildIdx;
		bool hasName;
		AssetTypeTemplateField templateBase;
		inline NameTypeCacheValue()
			: nameChildIdx(0), hasName(false), templateBase()
		{}
		inline NameTypeCacheValue(DWORD nameChildIdx, AssetTypeTemplateField&& templateBase)
			: nameChildIdx(nameChildIdx), templateBase(std::move(templateBase))
		{}
		NameTypeCacheValue(const NameTypeCacheValue& other) = delete;
		inline NameTypeCacheValue(NameTypeCacheValue&& other)
			: nameChildIdx(other.nameChildIdx), hasName(other.hasName), templateBase(std::move(other.templateBase))
		{
			other.hasName = false;
		}
		NameTypeCacheValue& operator=(const NameTypeCacheValue& other) = delete;
		inline NameTypeCacheValue& operator=(NameTypeCacheValue&& other)
		{
			nameChildIdx = other.nameChildIdx;
			hasName = other.hasName;
			templateBase = std::move(other.templateBase);
			other.hasName = false;
			return (*this);
		}
	};
	bool TryRetrieveAssetNameField(AssetsFileContextInfo* pContextInfo, AssetIdentifier& identifier, std::string& nameOut,
		std::unordered_map<NameTypeCacheKey, NameTypeCacheValue>& nameTypesCache);
	//Generates cache info for listEntries [start,end).
	//pFirstEntry (out) : The cache info for listEntries[start]
	//nMax : A limit on how many new items should be cached.
	//maxVisitedIndex (out, optional) : Receives the index after the highest (i.e. the last) visited list entry. Useful for overridden nMax.
	//                                  Set to start if no element was visited.
	//Returns the amount of new cached items.
	size_t cacheEntries(size_t start, size_t end, AssetInfo*& pFirstEntry, size_t nMax = SIZE_MAX, size_t* maxVisitedIndex = nullptr);
	inline void cacheEntry(size_t start, AssetInfo*& pFirstEntry)
	{
		cacheEntries(start, start + 1, pFirstEntry);
	}
	std::array<std::unique_ptr<TCHAR[]>, 4> lvStringBuf_Ownerdata;
	std::array<std::unique_ptr<TCHAR[]>, 4> lvStringBuf_Tooltip;

protected:
	static INT_PTR CALLBACK GotoDlgProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
	static INT_PTR CALLBACK SearchDlgProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
	static INT_PTR CALLBACK AssetListProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
	static LRESULT CALLBACK ListViewSubclassProc(HWND hWnd, UINT uMsg,
		WPARAM wParam, LPARAM lParam,
		uintptr_t uIdSubclass, DWORD_PTR dwRefData);
public:
	~AssetListDialog();
	AssetListDialog(class Win32AppContext* pContext, HWND hParentWnd);
	void bulk_SelectAllAssets();
	int bulk_nListEntries() {
		return this->listEntries.size();
	}
	void bulk_ExportAllAssets();
	void bulk_ExportAllTexture2D();
	void bulk_ImportAllTexture2D();
	void bulk_ImportAllAssets();
	static void writeNotifyFile(std::string notifyfile, void* mainWindow);
	EFileManipulateDialogType getType();
	void addFileContext(const std::pair<FileEntryUIInfo*, uintptr_t>& fileContext);
	void removeFileContext(FileEntryUIInfo* pEntryInfo);
	HWND getWindowHandle();
	void onHotkey(ULONG message, DWORD keyCode); //message : currently only WM_KEYDOWN; keyCode : VK_F3 for instance
	bool onCommand(WPARAM wParam, LPARAM lParam); //Called for unhandled WM_COMMAND messages. Returns true if this dialog has handled the request, false otherwise.

	void onUpdateContainers(AssetsFileContextInfo* pFile);
	void onChangeAsset(AssetsFileContextInfo* pFile, pathid_t pathID, bool wasRemoved);

	void onShow();
	void onHide();

	bool hasUnappliedChanges(bool* applyable = nullptr);
	bool applyChanges();
	bool doesPreferNoAutoclose();

	UABE_Win32_API void switchToListTab();
	UABE_Win32_API bool openViewDataTab(unsigned int fileID, pathid_t pathID);
	UABE_Win32_API bool selectAsset(unsigned int fileID, pathid_t pathID);

	UABE_Win32_API std::vector<AssetUtilDesc> getSelectedAssets();

	//Assumes all assets have resolved AssetIdentifiers already.
	template <class TaskGenerator>
		requires std::invocable<const TaskGenerator&, std::vector<AssetUtilDesc>, std::string>
	&& std::convertible_to<std::invoke_result_t<const TaskGenerator&, std::vector<AssetUtilDesc>, std::string>, std::shared_ptr<AssetExportTask>>
		UABE_Win32_API void exportAssetsBy(std::vector<AssetUtilDesc> assets,
			const TaskGenerator& taskGenerator, std::string extension, std::string extensionFilter);

	//Assumes all assets have resolved AssetIdentifiers already.
	template <class AssetExportTaskT>
		requires std::derived_from<AssetExportTaskT, AssetExportTask>
	&& std::constructible_from<AssetExportTaskT, std::vector<AssetUtilDesc>, std::string, std::string, std::string, bool>
		inline void exportAssetsBy(std::vector<AssetUtilDesc> assets,
			std::string extension, std::string extensionFilter, std::string taskName, bool stopOnError = false)
	{
		return exportAssetsBy(std::move(assets),
			[&](std::vector<AssetUtilDesc> assets, std::string baseDir) {
				return std::static_pointer_cast<AssetExportTask>(
					std::make_shared<AssetExportTaskT>(std::move(assets), taskName, extension, std::move(baseDir), stopOnError));
			}, extension, extensionFilter);
	}
	//Assumes all assets have resolved AssetIdentifiers already.
	template <class AssetExportTaskT>
		requires std::derived_from<AssetExportTaskT, AssetExportTask>
	&& std::constructible_from<AssetExportTaskT, class Win32AppContext&, std::vector<AssetUtilDesc>, std::string, std::string, std::string, bool>
		inline void exportAssetsBy(std::vector<AssetUtilDesc> assets,
			class Win32AppContext& appContext, std::string extension, std::string extensionFilter,
			std::string taskName, bool stopOnError = false)
	{
		return exportAssetsBy(std::move(assets),
			[&](std::vector<AssetUtilDesc> assets, std::string baseDir) {
				return std::static_pointer_cast<AssetExportTask>(
					std::make_shared<AssetExportTaskT>(appContext, std::move(assets), taskName, extension, std::move(baseDir), stopOnError));
			}, extension, extensionFilter);
	}

	//Assumes all assets have resolved AssetIdentifiers already.
	inline void exportAssetsRaw(std::vector<AssetUtilDesc> assets, bool stopOnError = false)
	{
		return exportAssetsBy<AssetExportRawTask>(std::move(assets), ".dat", "*.*|All types:", "Export raw assets", stopOnError);
	}
	//Assumes all assets have resolved AssetIdentifiers already.
	UABE_Win32_API void exportAssetsTextDump(std::vector<AssetUtilDesc> assets, bool stopOnError = false);
	//Assumes all assets have resolved AssetIdentifiers already.
	UABE_Win32_API void exportAssetsJSONDump(std::vector<AssetUtilDesc> assets, bool stopOnError = false);

	//Assumes all assets have resolved AssetIdentifiers already.
	template <class TaskGenerator>
		requires std::invocable<const TaskGenerator&, std::vector<AssetUtilDesc>, std::vector<std::string>>
	&& std::convertible_to<std::invoke_result_t<const TaskGenerator&, std::vector<AssetUtilDesc>, std::vector<std::string>>,
		std::shared_ptr<AssetImportTask>>
		UABE_Win32_API void importAssetsBy(std::vector<AssetUtilDesc> assets,
			const TaskGenerator& taskGenerator, std::string extension, std::string extensionRegex, std::string extensionFilter);

	//Assumes all assets have resolved AssetIdentifiers already.
	template <class AssetImportTaskT>
		requires std::derived_from<AssetImportTaskT, AssetImportTask>
	&& std::constructible_from<AssetImportTaskT, class Win32AppContext&, std::vector<AssetUtilDesc>, std::vector<std::string>, std::string, bool>
		inline void importAssetsBy(std::vector<AssetUtilDesc> assets,
			class Win32AppContext& appContext, std::string extension, std::string extensionRegex, std::string extensionFilter,
			std::string taskName, bool stopOnError = false)
	{
		return importAssetsBy(std::move(assets),
			[&appContext, &taskName, stopOnError](std::vector<AssetUtilDesc> assets, std::vector<std::string> paths) {
				return std::static_pointer_cast<AssetImportTask>(
					std::make_shared<AssetImportTaskT>(appContext, std::move(assets), std::move(paths), taskName, stopOnError));
			}, std::move(extension), std::move(extensionRegex), std::move(extensionFilter));
	}

	//Assumes all assets have resolved AssetIdentifiers already.
	UABE_Win32_API void importAssetsRaw(std::vector<AssetUtilDesc> assets, bool stopOnError = false);
	//Assumes all assets have resolved AssetIdentifiers already.
	UABE_Win32_API void importAssetsDump(std::vector<AssetUtilDesc> assets, bool stopOnError = false);
};

